# Git
---
#### * взято с ресурса https://www.yourtodo.ru/posts/shpargalka-po-git-komandam/*
---

это система контроля версий, которая позволяет эффективно управлять и отслеживать изменения в исходном коде и других файлах. Git позволяет многим людям работать с одним и тем же проектом, внося изменения и сливая их вместе в единую версию. Git является одной из самых популярных систем контроля версий и широко используется в различных проектах, включая разработку программного обеспечения, научные исследования, веб-сайты и многое другое.

История Git начинается в 2005 году, когда Линус Торвальдс, создатель ядра Linux, начал разработку новой системы контроля версий для управления исходным кодом ядра Linux. Он был недоволен тогдашними системами контроля версий, которые были неэффективными или сложными в использовании. Git был создан как быстрый, эффективный и легко расширяемый инструмент для работы с крупными проектами с распределенной архитектурой.

С тех пор Git стал не только популярным среди разработчиков Linux, но и быстро распространился по всему миру и стал одним из самых используемых инструментов в различных областях. Git является свободным программным обеспечением с открытым исходным кодом, что позволяет всем желающим использовать, изменять и распространять его бесплатно.

Основные действия с репозиторием
```
git init
```
Команда git init используется для создания нового локального репозитория Git. После выполнения этой команды Git создает в текущей директории новую поддиректорию с именем .git, в которой хранятся все файлы Git, необходимые для управления версиями в этом репозитории.

Синтаксис команды git init:
```
git init [--bare] [<directory>]
```
--bare - определяет репозиторий как "голый", т.е. без рабочей директории. Это используется для создания удаленного репозитория.

<directory> - указывает директорию, в которой создается локальный репозиторий. Если параметр не указан, репозиторий создается в текущей директории.

Пример использования команды git init:
```
$ cd my_project
$ git init
Initialized empty Git repository in /path/to/my_project/.git/
```
Эта команда создает новый локальный репозиторий Git в текущей директории my_project. Git создает поддиректорию .git и инициализирует ее файлами, необходимыми для управления версиями.

Флаг --bare используется для создания "голого" удаленного репозитория. Например:

$ mkdir my_repo.git
$ cd my_repo.git
$ git init --bare
Initialized empty Git repository in /path/to/my_repo.git/
Эта команда создает новый удаленный репозиторий Git в директории my_repo.git. Флаг --bare указывает, что это "голый" репозиторий, т.е. без рабочей директории.

Команда git init также поддерживает другие опции и флаги, которые можно использовать в различных сценариях. Например, флаг --template позволяет указать кастомный шаблон инициализации, а опция --separate-git-dir позволяет разместить репозиторий в другой директории. Список всех опций и флагов можно посмотреть в документации Git.

git clone
Команда git clone используется для создания локальной копии удаленного репозитория Git. Это позволяет вам получить копию проекта на вашем локальном компьютере и начать работу с ним.

Синтаксис команды git clone:

git clone <URL репозитория> [<название локальной папки>]
где <URL репозитория> - это URL-адрес удаленного репозитория Git, а <название локальной папки> (необязательный параметр) - это название локальной папки, в которую будет склонирован репозиторий. Если <название локальной папки> не указан, Git автоматически создаст папку с названием репозитория.

Пример использования команды git clone:

git clone https://github.com/username/repo.git
Эта команда создаст локальную копию удаленного репозитория repo, который находится в аккаунте username на GitHub, в папке с названием repo.

Если вы хотите указать свое собственное название для локальной папки, вы можете добавить его после URL-адреса репозитория:

git clone https://github.com/username/repo.git myproject
Эта команда создаст локальную копию удаленного репозитория repo в папке myproject. Если папка myproject уже существует, Git выведет сообщение об ошибке и не склонирует репозиторий.

Работа с изменениями
git add
Команда git add . используется для добавления изменений в индекс Git. Индекс - это промежуточный слой между рабочей директорией (где находятся ваши файлы) и репозиторием Git (где сохраняются изменения). Когда вы делаете изменения в файлах в рабочей директории, они не автоматически добавляются в индекс. Для того, чтобы добавить изменения в индекс, необходимо использовать команду git add.

Синтаксис команды git add . :

git add .
Эта команда добавляет все измененные файлы в рабочей директории в индекс.

Пример использования команды git add . :

Создайте новый файл с названием file.txt в вашей рабочей директории и добавьте в него какой-то текст.

Выполните команду git status, чтобы увидеть изменения в рабочей директории:

$ git status
On branch master
Untracked files:
(use "git add <file>..." to include in what will be committed)
file.txt

nothing added to commit but untracked files present (use "git add" to track)
Вы видите, что файл file.txt еще не отслеживается Git.

Выполните команду git add ., чтобы добавить все измененные файлы в рабочей директории в индекс:

$ git add .
Снова выполните команду git status, чтобы увидеть изменения в индексе:

$ git status
On branch master
Changes to be committed:
(use "git restore --staged <file>..." to unstage)
new file: file.txt
Вы видите, что файл file.txt был добавлен в индекс.

Выполните команду git commit, чтобы сохранить изменения в репозитории Git:

$ git commit -m "Added file.txt"
[master 0e3b0a7] Added file.txt
1 file changed, 1 insertion(+)
create mode 100644 file.txt
Вы видите, что файл file.txt был успешно добавлен в репозиторий Git.

Команда git add . очень полезна, когда вам нужно добавить много файлов в индекс одновременно. Однако, будьте осторожны, когда используете эту команду, особенно если вы работаете в большом проекте с множеством файлов. В некоторых случаях вам может потребоваться выбирать файлы для добавления в индекс более тщательно, чтобы избежать случайного добавления ненужных файлов.

git commit
Команда git commit используется для сохранения изменений, сделанных в вашем локальном репозитории, в истории коммитов. Каждый коммит в Git имеет уникальный идентификатор, дату и время коммита, имя автора, электронную почту и сообщение, описывающее изменения.

Синтаксис команды git commit:

git commit -m "<сообщение коммита>"
Где -m означает "message" (сообщение) и <сообщение коммита> - это краткое описание изменений, сделанных в коммите.

Пример использования команды git commit:

Добавьте изменения в индекс с помощью команды git add (например, git add filename.txt или git add . для добавления всех измененных файлов в индекс). Сделайте коммит с помощью команды git commit и передайте сообщение коммита в кавычках, чтобы описать, что было изменено. Например:

git commit -m "Добавлен новый файл README.md"
После выполнения команды, Git сохранит изменения в истории коммитов, и сообщение коммита будет отображаться в списке коммитов.
Важно отметить, что каждый коммит должен иметь уникальное сообщение, которое описывает изменения в нем. Это помогает вам и другим членам команды понимать, что было изменено и почему.

Кроме того, команду git commit можно дополнительно настраивать, используя различные параметры, например, -a (автоматически добавляет все измененные файлы в индекс) или --amend (используется для изменения последнего коммита). Для получения подробной информации о доступных параметрах команды git commit можно обратиться к документации Git.

git diff
Команда git diff используется для просмотра различий между версиями файлов в репозитории. Она показывает, какие изменения были сделаны в файлах с момента последнего коммита.

Основной синтаксис команды git diff выглядит так:

git diff [<опции>] [<источник>] [<цель>]
Где:

<источник> - определяет начальную точку изменений для отображения различий.
<цель> - определяет конечную точку изменений для отображения различий.
<опции> - дополнительные флаги, изменяющие поведение команды.

Основные флаги git diff:

--cached - сравнивает изменения между вашим индексом (т.е. тем, что будет в следующем коммите) и последним коммитом.
--stat - показывает статистику изменений для каждого файла.
--color - отображает различия с использованием цветов для лучшей читаемости.

Примеры использования:

git diff - простой запуск команды покажет различия между вашей рабочей копией и последним коммитом.
git diff --cached - покажет различия между вашим индексом и последним коммитом.
git diff HEAD - покажет различия между вашей рабочей копией и последним коммитом.
git diff HEAD~2 HEAD - покажет различия между двумя последними коммитами.
git diff --stat - покажет статистику изменений для каждого файла.
git diff --color - покажет различия с использованием цветов.
Кроме того, можно использовать git diff для сравнения любых двух коммитов, веток или тэгов в репозитории. Например, git diff branch1..branch2 покажет различия между двумя ветками branch1 и branch2.

git revert
Команда git revert используется для отмены определенного коммита и создания нового коммита, который отменяет изменения предыдущего коммита. Это делает команду безопасной для использования в общем репозитории, поскольку она не изменяет историю коммитов.

Синтаксис команды git revert:

git revert <commit>
где <commit> - это хэш-идентификатор коммита, который нужно отменить.

Пример использования команды git revert:

$ git log --oneline
d3b3d43 Commit C
786f7f8 Commit B
12556fa Commit A

$ git revert d3b3d43
Эта команда создаст новый коммит, который отменяет изменения, внесенные коммитом с хэш-идентификатором d3b3d43.

Флаги:

--no-commit: применить изменения, но не создавать новый коммит. Это позволяет вам проверить изменения перед тем, как закоммитить их.
-m parent-number: используется, если коммит имеет несколько родительских коммитов (как в случае с объединением веток). Он указывает, какой из родительских коммитов следует использовать при выполнении операции отмены.

Пример использования команды git revert с флагом --no-commit:

$ git revert --no-commit d3b3d43
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
        modified:   file.txt
Эта команда отменяет изменения, внесенные коммитом с хэш-идентификатором d3b3d43, и добавляет их в индекс. Но новый коммит не создается, пока не будет выполнена команда git commit.

git stash
Команда git stash используется для временного сохранения всех несохранённых изменений в вашем рабочем пространстве и индексе (т.е., staged changes), чтобы вы могли работать на чистой кодовой базе. Это очень полезно, когда вам нужно быстро переключиться между ветками, не теряя текущую работу.

Синтаксис команды git stash:

git stash push [-m <message>] [--include-untracked] [--keep-index]
Основные флаги:

-m <message> или --message <message>: добавляет пользовательское сообщение к stash для удобства идентификации.
--include-untracked: включает в stash файлы, которые не отслеживаются Git (т.е., новые файлы, которые не были добавлены в индекс).
--keep-index: сохраняет изменения, которые уже были добавлены в индекс (staged changes), в вашем рабочем каталоге после создания stash.
Пример использования команды git stash:

$ git stash push -m "Временное сохранение изменений перед переключением веток"
После выполнения команды все текущие изменения в рабочем каталоге и индексе будут сохранены в стеке stash, и ваш рабочий каталог вернётся к состоянию последнего коммита. Вы можете вернуться к своим изменениям позже, используя команду git stash pop или git stash apply.

Команда git stash позволяет эффективно управлять временными изменениями, не мешая основной работе и без необходимости создания коммитов для незаконченной работы.

git stash pop
Команда git stash pop используется для применения изменений из последнего сохранения в стеке stash к текущему рабочему каталогу и удаления этого сохранения из стека. Это позволяет вам восстановить изменения, которые вы временно сохранили с помощью команды git stash push, и продолжить работу с ними.

Синтаксис команды git stash pop:

git stash pop [--index] [<stash>]
Основные флаги:

--index: Применяет не только изменения в рабочем каталоге, но и восстанавливает состояние индекса (staged changes) на момент создания stash. Это полезно, если вы хотите сохранить разделение между staged и unstaged изменениями.
<stash>: Вы можете указать конкретное сохранение из стека stash, которое хотите применить, используя его имя (например, stash@{0}). Если аргумент не указан, по умолчанию используется последнее сохранение (stash@{0}).
Пример использования команды git stash pop:

$ git stash pop
После выполнения этой команды изменения из последнего сохранения в стеке stash будут применены к вашему текущему рабочему каталогу, а сохранение будет удалено из стека. Если при применении возникнут конфликты, вы должны будете их разрешить вручную, и сохранение не будет удалено из стека до полного разрешения конфликтов.

Использование команды git stash pop позволяет легко возвращаться к работе над временно отложенными изменениями, обеспечивая эффективное управление вашим рабочим процессом.

git stash apply
Команда git stash apply используется для применения изменений из сохранённого состояния в стеке stash к текущему рабочему каталогу без удаления этих изменений из стека stash. Это позволяет вам восстановить изменения, которые вы временно сохранили, и продолжить работу с ними, при этом сохраняя копию этих изменений в стеке stash для возможного будущего использования.

Синтаксис команды git stash apply:

git stash apply [--index] [<stash>]
Основные флаги:

--index: При использовании этого флага, команда пытается восстановить не только изменения в рабочем каталоге, но и staged изменения, которые были сохранены в stash. Это позволяет вам сохранить разделение между staged и unstaged изменениями на момент создания stash.
<stash>: Вы можете указать конкретное сохранение из стека stash, которое хотите применить, используя его идентификатор (например, stash@{0}). Если аргумент не указан, по умолчанию применяется последнее сохранение (stash@{0}).
Пример использования команды git stash apply:

$ git stash apply
Эта команда применит изменения из последнего сохранения в стеке stash к вашему текущему рабочему каталогу, но в отличие от git stash pop, сохранение останется в стеке stash. Если при применении возникнут конфликты, вам необходимо будет разрешить их вручную. Команда не удаляет применённое сохранение из стека, позволяя вам использовать его повторно в будущем или применить в другой ветке.

Использование git stash apply предоставляет гибкость в управлении временно сохранёнными изменениями, позволяя вам восстановить работу над ними без удаления из стека stash, что может быть полезно для тестирования изменений в разных ветках.

git stash list
Команда git stash list отображает список всех сохранённых состояний (stash-ей), которые были созданы в репозитории с помощью команды git stash push. Этот список позволяет просмотреть все временно сохранённые изменения, чтобы вы могли легко идентифицировать и выбрать нужное сохранение для применения или удаления.

Синтаксис команды git stash list не требует дополнительных аргументов:

git stash list
После выполнения команды вы увидите список всех stash-ей, сохранённых в вашем репозитории. Каждое сохранение в списке будет иметь свой уникальный индекс в формате stash@{N}, где N - номер сохранения в стеке, и краткое описание, включая имя ветки, из которой был сделан stash, и сообщение, если оно было добавлено при создании stash.

Пример вывода команды git stash list:

stash@{0}: On master: feature added
stash@{1}: On develop: bug fix
Этот вывод показывает, что в репозитории есть два сохранённых изменения: первое (stash@{0}) содержит изменения с сообщением "feature added" из ветки master, а второе (stash@{1}) - изменения с сообщением "bug fix" из ветки develop.

Использование команды git stash list обеспечивает удобный способ просмотра и управления вашими временными изменениями, позволяя легко выбрать нужное сохранение для дальнейших действий, таких как применение (git stash apply) или удаление (git stash drop).

Управление историей
git reset
Команда git reset используется для отмены изменений в вашем локальном репозитории. Она позволяет сбрасывать состояние вашего рабочего каталога до определённого коммита, изменяя при этом историю коммитов и/или состояние индекса (staging area). В зависимости от используемых опций, git reset может изменять HEAD (текущий коммит), индекс и рабочий каталог.

Синтаксис команды git reset:

git reset [--soft | --mixed | --hard] <commit>
Основные опции:

--soft: Сбрасывает HEAD до указанного коммита, но оставляет рабочий каталог и индекс (staging area) без изменений. Изменения, которые были сделаны после указанного коммита, останутся в индексе, готовые к коммиту.
--mixed (по умолчанию): Сбрасывает HEAD и индекс до указанного коммита, но оставляет рабочий каталог без изменений. Это означает, что изменения, которые были проиндексированы, будут отменены, но останутся в рабочем каталоге как неиндексированные изменения.
--hard: Сбрасывает HEAD, индекс и рабочий каталог до состояния указанного коммита. Все изменения в рабочем каталоге и индексе будут потеряны. Эту опцию следует использовать с осторожностью.
Пример использования команды git reset:

Для отмены последних двух коммитов и возвращения изменений в рабочий каталог (неиндексированные изменения):

$ git reset --mixed HEAD~2
Для полного удаления последних двух коммитов, включая все изменения в рабочем каталоге:

$ git reset --hard HEAD~2
Использование команды git reset обеспечивает отличный инструмент для управления историей ваших коммитов и состоянием индекса, позволяя исправлять ошибки в истории коммитов или отменять изменения до их публикации в удалённом репозитории. Однако, использование --hard может привести к потере данных, поэтому перед его применением рекомендуется убедиться в отсутствии важных несохранённых изменений.

git log
Команда git log используется для просмотра истории коммитов в репозитории Git. Она отображает список коммитов в обратном хронологическом порядке, начиная с последнего.

Пример использования команды git log:

git log
Эта команда показывает список всех коммитов в репозитории, от самых последних до самых старых. Каждый коммит включает SHA-1 хеш, автора коммита, дату и время коммита, и комментарий.

Основные флаги команды git log:

--oneline: показывает каждый коммит в одной строке, содержащей только его SHA-1 хеш и комментарий.

--graph: показывает историю коммитов в виде графа, что позволяет легко визуализировать разветвленную историю ветвлений и слияний.

--author=<имя>: показывает только коммиты, сделанные указанным автором.

--since=<дата>: показывает только коммиты, сделанные после указанной даты.

--until=<дата>: показывает только коммиты, сделанные до указанной даты.

-n <количество>: показывает только указанное количество последних коммитов.

--grep=<строка>: показывает только коммиты, содержащие указанную строку в своих комментариях.

Пример использования флага --since:

git log --since=2022-01-01
Эта команда показывает список всех коммитов, сделанных после 1 января 2022 года.

Пример использования флага --author:

git log --author="John Doe"
Эта команда показывает список всех коммитов, сделанных автором с именем "John Doe".

Пример использования флага --grep:

git log --grep="bug"
Эта команда показывает список всех коммитов, содержащих слово "bug" в своих комментариях.

git checkout
Команда git checkout в Git используется для переключения между ветками, проверки коммитов и отката изменений. Она позволяет переключаться между различными состояниями вашего репозитория.

Основные флаги:

-b: создать новую ветку и переключиться на нее. Например, git checkout -b new-branch создаст новую ветку с названием "new-branch" и переключится на нее.
-f: принудительно перезаписывает локальные изменения, которые не были зафиксированы. Этот флаг используется только в крайних случаях.
-p: позволяет просмотреть и выбрать конкретные изменения для восстановления.
<commit/branch>: позволяет переключиться на определенный коммит или ветку.

Примеры использования:

Переключение на ветку:

git checkout main
Эта команда переключает вас на ветку "main".

Создание новой ветки и переключение на нее:

git checkout -b new-branch
Эта команда создает новую ветку с названием "new-branch" и переключает вас на нее.

Переключение на определенный коммит:

git checkout 2a3e8c9
Эта команда переключает вас на коммит с указанным идентификатором.

Отмена изменений в файле:

git checkout myfile.txt
Эта команда отменяет изменения в файле "myfile.txt" и восстанавливает его до последней зафиксированной версии.

Восстановление определенных изменений:

git checkout -p myfile.txt
Эта команда позволяет вам просмотреть изменения в файле "myfile.txt" и выбрать, какие из них восстановить.

Управление ветками
git branch
Команда git branch используется для просмотра, создания и удаления веток в репозитории Git. Ветка - это отдельная линия разработки, которая может включать в себя свой собственный набор коммитов.

Основные флаги команды git branch:

-a - показывает все ветки (включая удаленные)
-d - удаляет ветку (данная команда удаляет только те ветки, которые были слиты в текущую ветку)
-D - удаляет ветку без проверки, были ли все её изменения слиты с текущей веткой
-m - переименовывает текущую ветку
-r - показывает все удаленные ветки

Примеры использования команды git branch:

Просмотр списка веток:

git branch
Создание новой ветки:

git branch new-branch
Переименование текущей ветки:

git branch -m new-branch-name
Удаление ветки:

git branch -d branch-to-delete
Просмотр удаленных веток:

git branch -r
Команда git branch позволяет управлять ветками в репозитории и помогает организовать работу в команде. Она также помогает контролировать историю изменений в проекте.

git merge
Команда git merge используется для объединения изменений из одной ветки в другую. Она применяется для слияния изменений, которые были внесены в отдельной ветке, обычно для объединения фиксации ошибок или добавления функциональности в проект.

Синтаксис команды git merge:

git merge <имя ветки>
где <имя ветки> - это имя ветки, изменения из которой вы хотите объединить в текущую ветку.

Пример использования команды git merge:

Сначала, вам нужно переключиться на ветку, в которую вы хотите объединить изменения:

git checkout master
Затем вы можете выполнить команду git merge, указав имя ветки, из которой вы хотите получить изменения:

git merge feature-branch
В этом примере мы объединяем изменения из ветки feature-branch в текущую ветку master.

Основные флаги команды git merge:

--no-ff: Отключает быстрое слияние, что создает коммит с объединением, даже если изменения можно было бы просто быстро применить.
--abort: Отменяет текущее слияние и возвращает репозиторий в предыдущее состояние.

Пример использования флага --no-ff:

git merge --no-ff feature-branch
В этом примере мы отключаем быстрое слияние и создаем новый коммит с объединением.

Пример использования флага --abort:

git merge --abort
В этом примере мы отменяем текущее слияние и возвращаем репозиторий в предыдущее состояние.

git rebase
Команда git rebase используется для перебазирования текущей ветки на другую ветку или на определенный коммит. Это означает, что изменения из исходной ветки будут применены поверх коммитов в целевой ветке или коммите.

Основные флаги:

-i (или --interactive): запускает интерактивный режим, который позволяет изменять порядок, объединять или отбрасывать коммиты.
-m (или --merge): используется, когда нужно перебазировать ветку слияния.
--onto <branch>: перебазирует текущую ветку на указанную ветку.

Примеры использования команды git rebase:

Перебазирование текущей ветки на другую ветку:

git checkout feature-branch
git rebase main
В этом примере текущая ветка feature-branch перебазируется на ветку main. Это означает, что изменения из ветки main будут применены поверх коммитов в ветке feature-branch.

Перебазирование текущей ветки на определенный коммит:

git checkout feature-branch
git rebase abc123
В этом примере текущая ветка feature-branch перебазируется на коммит с хеш-кодом abc123. Это означает, что изменения из этого коммита и всех коммитов после него будут применены поверх коммитов в ветке feature-branch.

Использование интерактивного режима:

git checkout feature-branch
git rebase -i main
В этом примере запускается интерактивный режим, который позволяет изменять порядок, объединять или отбрасывать коммиты при перебазировании ветки feature-branch на ветку main.

Перебазирование ветки слияния:

git checkout merge-branch
git rebase -m main
В этом примере ветка merge-branch, являющаяся веткой слияния, перебазируется на ветку main. Опция -m используется для корректной обработки коммитов слияния.

Работа с удаленным репозиторием
git fetch
Команда git fetch используется для получения изменений из удаленного репозитория Git, но не вносит изменения в локальную ветку. Эта команда позволяет вам получить информацию о ветках и коммитах, которых еще нет в локальном репозитории.

Синтаксис команды git fetch:

git fetch [<remote>] [<refspec>...]
Основные флаги:

<remote>: имя удаленного репозитория Git (например, origin). Если не указан, Git использует имя origin по умолчанию.
<refspec>: имена веток и тегов, которые вы хотите получить из удаленного репозитория. Если не указан, Git получает все ветки и теги.

Пример использования команды git fetch:

git fetch
Эта команда получает все изменения из удаленного репозитория Git, который связан с вашим локальным репозиторием. После выполнения этой команды вы можете выполнить команду git log origin/master для просмотра истории изменений в удаленной ветке master.

git fetch origin feature-branch
Эта команда получает все изменения из удаленной ветки feature-branch в удаленном репозитории Git, связанном с вашим локальным репозиторием. После выполнения этой команды вы можете выполнить команду git log origin/feature-branch для просмотра истории изменений в удаленной ветке feature-branch.

git pull
Команда git pull используется для получения изменений из удаленного репозитория и объединения их с вашей локальной веткой.

Основной синтаксис команды git pull выглядит следующим образом:

git pull [<options>] [<repository> [<refspec>...]]
Основные флаги git pull:

--rebase: выполняет перебазирование текущей ветки на самый новый коммит вместо создания слияния (merge). Рекомендуется использовать этот флаг, если вы хотите, чтобы история коммитов оставалась простой и понятной.
--no-rebase: отменяет перебазирование и выполняет слияние вместо этого.
--no-commit: предотвращает создание автоматического коммита после выполнения слияния. Это дает возможность внести дополнительные изменения перед фиксацией изменений.
--ff-only: выполнить слияние только в том случае, если это можно сделать быстрым перемещением ветки вперед (fast-forward).
--no-ff: выполнить слияние только как коммит слияния (merge commit), даже если это можно сделать быстрым перемещением ветки вперед.

Примеры использования команды git pull:

Простой git pull, который получает изменения из удаленной ветки и автоматически объединяет их с локальной веткой:

git pull
git pull с использованием флага --rebase, который перебазирует текущую ветку на самый новый коммит из удаленной ветки вместо создания слияния:

git pull --rebase
git pull с использованием флага --no-commit, который предотвращает создание автоматического коммита после выполнения слияния:

git pull --no-commit
git pull с использованием флага --ff-only, который выполнит слияние только в том случае, если это можно сделать быстрым перемещением ветки вперед (fast-forward):

git pull --ff-only
git pull с использованием флага --no-ff, который выполнит слияние только как коммит слияния (merge commit), даже если это можно сделать быстрым перемещением ветки вперед:

git pull --no-ff
git push
Команда git push используется для отправки изменений из вашего локального репозитория в удаленный репозиторий Git. Это позволяет обновить содержимое удаленного репозитория на основе ваших локальных изменений.

Синтаксис команды git push:

git push <remote> <branch>
Где <remote> - это имя удаленного репозитория, куда вы хотите отправить изменения, а <branch> - это название ветки, которую вы хотите отправить.

Пример использования команды git push:

git push origin main
Эта команда отправляет изменения из вашей локальной ветки main в удаленный репозиторий с именем origin.

Помимо базового синтаксиса, команда git push имеет несколько флагов, которые можно использовать для дополнительной настройки:

-u или --set-upstream - устанавливает отслеживание для ветки, что позволяет вам использовать git push и git pull без указания имени удаленного репозитория и названия ветки;
-f или --force - заставляет Git принудительно заменить удаленную ветку измененной локальной веткой, даже если это приведет к потере данных;
-n или --dry-run - позволяет вам протестировать команду git push, не отправляя реальных изменений в удаленный репозиторий;
-v или --verbose - выводит дополнительную информацию о процессе отправки изменений.

Пример использования команды git push с флагом:

git push -u origin main
Эта команда отправляет изменения из вашей локальной ветки main в удаленный репозиторий с именем origin и устанавливает отслеживание для этой ветки.

Работа с файлами
git status 
Команда git status используется для получения информации о текущем состоянии вашего рабочего пространства Git. Она показывает, какие файлы были изменены, какие из них были добавлены в индекс, и какие из них готовы к коммиту. Кроме того, команда "git status" сообщает о текущей ветке и другой полезной информации.

Синтаксис команды "git status":

git status [-s] [--long] [--branch] [--porcelain] [--ignore-submodules[=<when>]]
Основные флаги:

"-s" или "--short": показывает краткую информацию о состоянии файлов в формате "git diff --shortstat".
"--long": показывает длинный формат состояния файлов, включая информацию о последнем коммите для каждого файла.
"--branch": показывает текущую ветку и ее состояние.
"--porcelain": показывает состояние файлов в машинно-читаемом формате, что полезно для автоматизации.
"--ignore-submodules": позволяет игнорировать изменения в подмодулях.

Пример использования команды "git status":

$ git status

На ветке main
Ваша ветка опережает «origin/main» на 1 коммит.
  (используйте «git push», чтобы опубликовать локальные коммиты)

изменения, которые будут включены в коммит:
  (используйте «git restore --staged <file>...», чтобы убрать из индекса)

        изменён:   README.md

изменения, которые не проиндексированы для коммита:
  (используйте «git add <file>...», чтобы проиндексировать)

        изменён:   index.html

нет изменений добавленных для коммита (используйте «git add» и/или «git commit -a»)
Эта команда показывает, что находитесь на ветке "main", ваша локальная ветка опережает ветку "origin/main" на один коммит, и что были внесены изменения в файлы "README.md" и "index.html". Файл "README.md" был проиндексирован и готов к коммиту, а файл "index.html" не был проиндексирован. Для того, чтобы проиндексировать файл "index.html", нужно использовать команду "git add index.html".

git rm
Команда git rm используется для удаления файлов из рабочего каталога и индекса (staging area). Это эффективный способ одновременно удалить файл из отслеживаемых и подготовить это изменение к коммиту. После применения команды файлы будут удалены из вашего рабочего каталога и не будут отслеживаться Git.

Синтаксис команды git rm:

git rm <file>...
Основные опции:

--cached: Удаляет файлы из индекса, сохраняя их в вашем рабочем каталоге. Это полезно, если вы хотите перестать отслеживать файл (например, добавить его в .gitignore), но не хотите физически удалять его из своей файловой системы.
-f или --force: Принудительно удаляет файлы, даже если они имеют изменения, отслеживаемые Git, или уже добавлены в индекс. Используйте с осторожностью, чтобы не потерять важные изменения.
Пример использования команды git rm:

Для удаления файла example.txt из рабочего каталога и индекса:

$ git rm example.txt
Для удаления файла config.ini только из индекса, сохраняя его в рабочем каталоге:

$ git rm --cached config.ini
После выполнения команды git rm, изменения готовы к коммиту. Это означает, что вы можете зафиксировать удаление файлов в истории репозитория, используя git commit.

Использование команды git rm обеспечивает чистый и управляемый способ удаления файлов из вашего репозитория, позволяя легко отслеживать и фиксировать такие изменения.

git mv
Команда git mv используется для перемещения или переименования файла или директории в репозитории Git. Это действие автоматически индексируется Git, что упрощает подготовку изменений к коммиту. В отличие от ручного переименования и последующего использования git add на новый файл и git rm на старый, git mv выполняет обе операции одновременно.

Синтаксис команды git mv:

git mv <источник> <назначение>
<источник>: текущее имя файла или директории.
<назначение>: новое имя файла или директории, или путь к директории, куда должен быть перемещён файл или директория.
Примеры использования команды git mv:

Переименование файла:

$ git mv староеИмя.txt новоеИмя.txt
Эта команда переименовывает файл староеИмя.txt в новоеИмя.txt и автоматически индексирует это изменение для следующего коммита.

Перемещение файла в директорию:

$ git mv example.txt директория/
Эта команда перемещает файл example.txt в директорию директория/ и также индексирует это изменение.

После выполнения команды git mv, изменения готовы к коммиту. Вы можете использовать git commit для зафиксирования переименования или перемещения файлов в истории вашего репозитория.

Использование команды git mv обеспечивает эффективный и простой способ управления файлами и директориями в вашем репозитории, автоматически отслеживая эти изменения в системе контроля версий.

Удаление случайно добавленных файлов из истории коммитов
Иногда в историю коммитов могут быть случайно добавлены крупные файлы или целые папки, например, обученные модели, размер которых превышает 100 Мб. В таких случаях на помощь приходит инструмент git-filter-repo, предназначенный для эффективной очистки истории репозитория.

Установка git-filter-repo

Перед началом работы с инструментом убедитесь, что он установлен. Вы можете установить git-filter-repo через pip следующим образом:

python3 -m pip install --user git-filter-repo
Очистка истории коммитов

Чтобы очистить историю от например от папки distil_bert/ вместе с её содержимым, используйте команду:

git filter-repo --invert-paths --path distil_bert/ --force
Если нужно удалить конкретный файл, укажите его полный путь:

git filter-repo --invert-paths --path 'predict/src/tasks/distil_bert/model.safetensors' --force
Восстановление связи с удалённым репозиторием

После применения git-filter-repo связь между локальным и удалённым репозиториями может быть потеряна. Для проверки текущей настройки удалённого репозитория выполните:

git remote -v
Эта команда отобразит URL для чтения и записи.

Если связь нарушена, добавьте удалённый репозиторий заново:

git remote add origin https://github.com/username/repo-name.git
Отправка изменений

Создайте новый коммит для зафиксированных изменений:

git add .
git commit -m "Remove large files"
Чтобы принудительно отправить изменения только для текущей ветки в удалённый репозиторий, используйте команду:

git push origin --force HEAD
 Чтобы принудительно обновить все ветки, отправьте изменения во все ветки удалённого репозитория:

git push origin --force --all
Это обновит историю на GitHub, сохранив вашу текущую работу, но обновит все незащищенные удаленные ветки локальными данными. Стоит быть очень внимательным и осторожным с этим, в последствии могут возникнуть проблемы при слиянии!

Важное напоминание

Принудительная отправка изменений в основные ветки может привести к потере важных данных для вашей команды. Обязательно согласуйте такие действия с коллегами, чтобы избежать конфликтов и потерь.